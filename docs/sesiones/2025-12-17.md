# Sesión 2025-12-17: Admin App y Gestión de Usuarios

## Objetivo
Crear una aplicación de administración web con Streamlit para gestionar usuarios y procesos del sistema FICEM CORE.

## Implementaciones

### 1. Aplicación Streamlit (admin_app.py)

Se creó una interfaz web completa para administradores FICEM con las siguientes características:

**Estructura**:
- Login con autenticación JWT
- Sidebar con información del usuario y menú
- 4 secciones principales: Dashboard, Usuarios, Procesos MRV, Submissions

**Funcionalidades implementadas**:
- Autenticación contra API FastAPI
- Gestión completa de usuarios (listar, filtrar, crear)
- Interfaz para procesos MRV (placeholder)
- Interfaz para submissions (placeholder)

**Tecnologías**:
- Streamlit 1.52.1
- Requests para consumir API REST
- JWT token storage en session_state

### 2. API REST - Gestión de Usuarios

Se implementó el módulo completo de gestión de usuarios en `api/routes/usuarios.py`:

**Endpoints**:
- `GET /api/v1/usuarios` - Listar con filtros (país, rol, activo)
- `GET /api/v1/usuarios/{id}` - Obtener usuario específico
- `POST /api/v1/usuarios` - Crear nuevo usuario
- `PUT /api/v1/usuarios/{id}` - Actualizar usuario
- `DELETE /api/v1/usuarios/{id}` - Desactivar usuario (soft delete)

**Seguridad**:
- Requiere autenticación JWT en todos los endpoints
- Solo usuarios ROOT y ADMIN_PROCESO pueden gestionar usuarios
- Validación de roles y permisos
- Hash de contraseñas con bcrypt

**Schemas Pydantic**:
- `UsuarioResponse` - Respuesta GET
- `UsuarioCreate` - Creación POST
- `UsuarioUpdate` - Actualización PUT

### 3. Script de Creación de Usuario Admin

Se creó `scripts/crear_usuario_admin.py` para inicializar el sistema:

**Funcionalidad**:
- Crea usuario ROOT inicial (credenciales desde variables de entorno)
- Opcionalmente crea usuarios de ejemplo para testing
- Verifica que no existan usuarios duplicados
- Hash seguro de contraseñas

**Usuarios de ejemplo**:
- Coordinador Perú: `coord.peru@asocem.org`
- Coordinador Colombia: `coord.colombia@ficem.org`
- Admin Procesos: `admin.proceso@ficem.org`

### 4. Actualización de Documentación

Se actualizaron los siguientes archivos:

**README.md**:
- Agregado paso de creación de usuario admin
- Documentados todos los endpoints implementados
- Agregada sección de Admin App Streamlit

**QUICKSTART.md**:
- Actualizado proceso de inicialización
- Agregadas instrucciones para ejecutar Streamlit
- Documentado uso de Admin App

**.env.example**:
- Agregada variable `API_URL` para Streamlit

## Estructura de Archivos Creados/Modificados

```
4c-ficem-core/
├── admin_app.py                          # Nueva - App Streamlit
├── api/
│   ├── main.py                           # Modificada - registrar ruta usuarios
│   └── routes/
│       └── usuarios.py                   # Nueva - CRUD usuarios
├── scripts/
│   └── crear_usuario_admin.py           # Nueva - setup inicial
├── README.md                             # Actualizada
├── QUICKSTART.md                         # Actualizada
├── .env.example                          # Actualizada
└── docs/
    └── sesiones/
        └── 2025-12-17.md                # Esta sesión
```

## Flujo de Trabajo Implementado

### Inicialización del Sistema
1. Configurar variables de entorno
2. Ejecutar migraciones Alembic
3. Crear usuario ROOT con script
4. Iniciar API FastAPI
5. (Opcional) Iniciar Admin App Streamlit

### Gestión de Usuarios
1. Login en Admin App con usuario ROOT
2. Navegar a sección "Usuarios"
3. Ver lista de usuarios existentes (filtrar por país/rol)
4. Crear nuevos usuarios con diferentes roles
5. Sistema valida permisos y crea usuario en BD

## Decisiones Técnicas

### Streamlit vs Frontend tradicional
- **Decisión**: Usar Streamlit para Admin App
- **Razón**:
  - Desarrollo rápido para operadores FICEM
  - No requiere React/Next.js para funcionalidad básica
  - Los frontends de país (4c-peru) seguirán usando Next.js
  - Streamlit es ideal para herramientas internas

### Soft Delete de Usuarios
- **Decisión**: No eliminar usuarios, solo desactivar
- **Razón**:
  - Mantener integridad referencial
  - Auditoría de quién creó qué submission
  - Posibilidad de reactivar usuarios

### JWT en Streamlit
- **Decisión**: Almacenar token en `st.session_state`
- **Razón**:
  - Simple y efectivo para app interna
  - No requiere cookies o localStorage
  - Token se pierde al cerrar sesión/browser (seguro)

## Comandos de Ejecución

### Iniciar servicios
```bash
# Terminal 1 - API
source venv/bin/activate
uvicorn api.main:app --reload --host 0.0.0.0 --port 8000

# Terminal 2 - Streamlit
source venv/bin/activate
streamlit run admin_app.py --server.port 8501
```

### Crear usuarios
```bash
# Usuario ROOT
python scripts/crear_usuario_admin.py

# Usuarios de ejemplo
echo "s" | python scripts/crear_usuario_admin.py
```

## URLs de Acceso

- **API Swagger**: http://localhost:8000/docs
- **Admin App**: http://localhost:8501
- **Login**: Credenciales en `storage/keys/DEV_CREDENTIALS.md`

## Notas

- La API se recarga automáticamente (--reload)
- Streamlit detecta cambios en admin_app.py
- Todos los endpoints requieren autenticación JWT
- Usuario ROOT tiene acceso total sin restricciones

---

## Corrección: Enum EstadoProceso (sesión 2)

### Problema
El endpoint `GET /api/v1/procesos` retornaba Error 500 al conectar admin_app.py con la API real.

### Causa raíz
Inconsistencia entre Python y PostgreSQL:
- Python enum: `"borrador"`, `"activo"` (minúsculas)
- PostgreSQL CHECK constraint: `'borrador'`, `'activo'` (minúsculas)
- Pero la convención del proyecto es MAYÚSCULAS

### Corrección aplicada
1. `database/models.py` - EstadoProceso: valores a MAYÚSCULAS
2. `api/schemas/procesos.py` - EstadoProceso: valores a MAYÚSCULAS
3. `admin_app.py` - Quitado `.lower()` del filtro de estado
4. PostgreSQL - CHECK constraint actualizado a MAYÚSCULAS
5. Datos existentes migrados a MAYÚSCULAS

### Lección
Documentar valores exactos de enums en `docs/USUARIOS_Y_PERMISOS.md` para evitar inconsistencias.

---

## Sesión 3: Cambios solicitados desde hr-arg (tarde)

**Solicitado por**: Carlos Pinilla (desde proyecto hr-arg)
**Fecha/Hora**: 2025-12-17 ~14:00

### 1. Corrección CHECK constraint submissions.estado_actual

**Problema**: POST /submissions retornaba Error 500.

**Causa**: CHECK constraint tenía valores minúsculas antiguas pero el código usa MAYÚSCULAS.

**Corrección**:
```sql
ALTER TABLE submissions DROP CONSTRAINT IF EXISTS check_estado;
ALTER TABLE submissions ADD CONSTRAINT check_estado CHECK (estado_actual IN (
    'BORRADOR', 'ENVIADO', 'APROBADO_EMPRESA', 'EN_REVISION_FICEM',
    'APROBADO_FICEM', 'RECHAZADO_EMPRESA', 'RECHAZADO_FICEM',
    'PUBLICADO', 'ARCHIVADO'
));
```

**Archivo actualizado**: `scripts/migrate_procesos_mrv.py` (valores del constraint)

### 2. Soporte para múltiples archivos por submission (IMPLEMENTADO)

**Requerimiento**: Un informante sube un archivo GNR por cada planta de su empresa, todo en un solo submission.

**Cambios implementados**:

#### 2.1 Modelo de datos (`database/models.py`)
```python
# Antes
archivo_excel = Column(JSONB, default=dict)

# Después
archivos_excel = Column(JSONB, default=list)
```

Estructura del array:
```json
[
    {
        "planta_id": 1,
        "planta_nombre": "Planta Olavarría",
        "url": "s3://ficem-uploads/AR/2024/holcim_olavarria.xlsx",
        "filename": "holcim_olavarria.xlsx",
        "size_bytes": 245678,
        "uploaded_at": "2024-11-15T14:30:00"
    }
]
```

#### 2.2 Schemas Pydantic (`api/schemas/procesos.py`)
- Nuevo schema `ArchivoExcelItem` para validar cada archivo
- `SubmissionResponse.archivos_excel` ahora es `List[Dict[str, Any]]`

#### 2.3 Endpoints modificados (`api/routes/submissions.py`)

**POST /submissions/{id}/upload** - Ahora requiere `planta_id`:
```python
@router.post("/submissions/{submission_id}/upload")
async def subir_archivo(
    submission_id: uuid.UUID,
    archivo: UploadFile = File(...),
    planta_id: int = Query(..., description="ID de la planta"),
    ...
):
```

**DELETE /submissions/{id}/archivos/{planta_id}** - Nuevo endpoint:
```python
@router.delete("/submissions/{submission_id}/archivos/{planta_id}")
async def eliminar_archivo(
    submission_id: uuid.UUID,
    planta_id: int,
    ...
):
```

**Validaciones actualizadas**:
- `POST /submissions/{id}/validar` ahora verifica `archivos_excel`
- `POST /submissions/{id}/submit` ahora verifica `archivos_excel`

#### 2.4 Migración de datos
```sql
-- Renombrar columna
ALTER TABLE submissions RENAME COLUMN archivo_excel TO archivos_excel;

-- Convertir objeto a array (datos existentes)
UPDATE submissions
SET archivos_excel = CASE
    WHEN archivos_excel IS NULL OR archivos_excel = '{}' THEN '[]'::jsonb
    ELSE jsonb_build_array(archivos_excel)
END;
```

**Estado**: ✅ Implementado y migrado

---

**Participantes**: Carlos Pinilla (usuario), Claude (asistente)
**Estado**: Completado ✅